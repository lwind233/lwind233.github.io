---
title: 42 接雨水
date: 2026-02-27T21:09:00
tags:
  - 单调栈
  - 双指针
categories:
  - 题解
  - hot100
---

先找全局最高柱 maxIdx，再把数组分成左右两段；左段每个位置的水位由“左侧最高”决定，右段由“右侧最高”决定。

对左边，从左边开始建立一个柱子单调递增的单调栈，这样两个柱子之间只会是凹槽。随后遍历这个栈，算出两个柱子之间的水量（水位由左侧较矮的柱子决定）。

对右边的处理方法相同。

```java
class Solution {
    public int trap(int[] height) {
        int l = height.length;
        int maxIdx = 0;
        int count=0;
        int left=0,right=0;

        for(int i=0;i<=l-1;i++){
            if(height[i]>height[maxIdx]) maxIdx = i;
        }

        Stack<Integer> s1 = new Stack<>();
        for(int i=0;i<=maxIdx;i++){
            if(height[i]!=0){
                if(s1.isEmpty()) s1.push(i);
                else{
                    if(height[i]>=height[s1.peek()]) s1.push(i);
                }
            }
        }
        
        if(s1.size()>=2){
            right = s1.pop();
            while(!s1.isEmpty()){
                left = s1.pop();
                for(int i=left+1;i<=right-1;i++){
                    count+=height[left]-height[i];
                }
                right = left;
            }
        }

        Stack<Integer> s2 = new Stack<>();
        for(int i=l-1;i>=maxIdx;i--){
            if(height[i]!=0){
                if(s2.isEmpty()) s2.push(i);
                else{
                    if(height[i]>=height[s2.peek()]) s2.push(i);
                }
            }
        }
        
        if(s2.size()>=2){
            left = s2.pop();
            while(!s2.isEmpty()){
                right = s2.pop();
                for(int i=left+1;i<=right-1;i++){
                    count+=height[right]-height[i];
                }
                left = right;
            }
        }

        return count;
    }
}
```
