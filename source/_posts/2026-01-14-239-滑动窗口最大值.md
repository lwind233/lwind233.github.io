---
title: 239 滑动窗口最大值
date: 2026-01-15 00:01:00
tags:
  - 堆
  - 单调队列
  - 栈与队列
  - 滑动窗口
  - 数组
categories:
  - 题解
  - hot100
abbrlink: f7491bcb
---

## 堆解法/延时删除

将值和下标存储进最大堆里，然后移动窗口，一边移动将新元素加入堆中，并判断当前堆的最大值是否在窗口里，如果不在就从堆中弹出，然后将当前窗口的最大值写入结果数组里

```java
class Solution {
    class Item{
        int value;
        int idx;
        public Item(int value, int idx){
            this.value = value;
            this.idx = idx;
        }
    }

    public int[] maxSlidingWindow(int[] nums, int k) {
        PriorityQueue<Item> pq = new PriorityQueue<>(1,(a,b)->(b.value-a.value));
        for(int i=1;i<=k-1;i++){
            Item tmp = new Item(nums[i-1],i-1);
            pq.offer(tmp);
        }
        int[] result = new int[nums.length-k+1];
        for(int i=0;i+k-1<=nums.length-1;i++){
            Item tmp = new Item(nums[i+k-1],i+k-1);
            pq.offer(tmp);
            while(pq.peek().idx<i) pq.poll();
            result[i] = pq.peek().value;
        }

        return result;
    }
}
```

## 单调队列解法

思路和堆解法类似，改用单调队列，单调队列内元素严格递减，每当新元素入队时，所有比它老的元素而且比它小的元素就再也不可能是最大值了，因此直接删除
当窗口移动出的最大值刚好与当前的最大值一致时，弹出单调队列的最大值
每移动一次窗口，向结果数组写入一次当前单调队列的最大值

```java
class Solution {

    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> monoStack = new LinkedList<>();
        int[] result = new int[nums.length-k+1];

        for(int i=1;i<=k-1;i++){
            if(monoStack.isEmpty()){
                monoStack.offer(nums[i-1]);
                continue;
            }
            while(!monoStack.isEmpty() && monoStack.peekLast()<nums[i-1]) monoStack.pollLast();
            monoStack.offer(nums[i-1]);
        }

        for(int i=0;i+k-1<=nums.length-1;i++){
            int tmp = nums[i+k-1];
            while(!monoStack.isEmpty() && monoStack.peekLast()<tmp) monoStack.pollLast();
            monoStack.offer(tmp);
            result[i] = monoStack.peekFirst();
            if(nums[i] == monoStack.peekFirst()) monoStack.pollFirst();
        }

        return result;
    }
}
```
