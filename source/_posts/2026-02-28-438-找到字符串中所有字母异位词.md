---
title: 438 找到字符串中所有字母异位词
date: 2026-02-28T17:49:00
tags:
  - 哈希表
  - 滑动窗口
  - 字符串
categories:
  - 题解
  - hot100
---

维护一个滑动窗口，将 p 转换为基于数组的哈希表，移动窗口时同步更新窗口的哈希表，最后与 p 的哈希表比较。

我的解法是变长滑动窗口——遇到超额字符时从左收缩，直到为新字符腾出空位。但这道题异位词长度必然等于 p 的长度，用定长滑动窗口更直接：右端进一个、左端出一个，一次遍历即可，不需要收缩逻辑。

踩到的两个坑：

* 用 LinkedHashMap 的 equals() 比较频次表，常数过大导致超时/报错
* 换成 int[] 后误用 array.equals()，该方法是引用比较而非内容比较，导致结果全为空——Java 中比较数组内容必须用 Arrays.equals()


```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        int[] sMap = new int[26];
        int[] pMap = new int[26];
        for(int i=0;i<=p.length()-1;i++){
            char tmpC = p.charAt(i);
            pMap[tmpC-'a'] = pMap[tmpC-'a']+1;
        }

        int left=-1;
        int right=0;
        for(;right<=s.length()-1;){
            char tmpSc = s.charAt(right);
            if(pMap[tmpSc-'a']==0){
                right++;
                left=-1;
                sMap = new int[26];
            }else{
                if(pMap[tmpSc-'a']==sMap[tmpSc-'a']){
                    while(pMap[tmpSc-'a']==sMap[tmpSc-'a'] && left<=right){
                        char lc = s.charAt(left);
                        sMap[lc-'a'] = sMap[lc-'a']-1;
                        left++;
                    }
                    sMap[tmpSc-'a'] = sMap[tmpSc-'a']+1;
                    right++;
                }else{
                    if(left==-1) left=right;
                    sMap[tmpSc-'a'] = sMap[tmpSc-'a']+1;
                    right++;
                }
            }
            if(Arrays.equals(pMap, sMap)) result.add(left);
        }

        return result;
    }
}
```
