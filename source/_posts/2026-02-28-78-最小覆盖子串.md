---
title: 78 最小覆盖子串
date: 2026-02-28T21:39:00
tags:
  - 滑动窗口
  - 双指针
  - 字符串
  - 哈希表
categories:
  - 题解
  - hot100
---

维护一个滑动窗口，这个窗口内的子串需要是覆盖子串

覆盖子串的条件：窗口内的字符种类数formed要大于子串的种类数required

formed增加条件：c是t中的字符，且t在窗口中的数量window等于需要的数量need

formed减少条件：c是t中的字符，且t在窗口中的数量window小于需要的数量need

首先初始化窗口，初始化为left=right=0
然后向右拓展，拓展后判断当前是否满足窗口内是覆盖子串
* 是，一边收缩左边界，一边记录有效覆盖子串的长度，直到无效
* 否，继续拓展，直到变回覆盖子串

```java
class Solution {
    public String minWindow(String s, String t) {
        if (t.length() == 0 || s.length() < t.length()) return "";

        int[] need = new int[128];
        int[] window = new int[128];

        int required = 0;
        for (int i = 0; i < t.length(); i++) {
            int c = t.charAt(i);
            if (need[c] == 0) required++;
            need[c]++;
        }

        int formed = 0;
        int bestLen = Integer.MAX_VALUE;
        int bestL = 0;

        int l = 0;
        for (int r = 0; r < s.length(); r++) {
            int c = s.charAt(r);
            window[c]++;

            if (need[c] > 0 && window[c] == need[c]) {
                formed++;
            }

            while (formed == required) {
                int len = r - l + 1;
                if (len < bestLen) {
                    bestLen = len;
                    bestL = l;
                }

                int d = s.charAt(l);
                window[d]--;
                if (need[d] > 0 && window[d] < need[d]) {
                    formed--;
                }
                l++;
            }
        }

        return bestLen == Integer.MAX_VALUE ? "" : s.substring(bestL, bestL + bestLen);
    }
}
```
