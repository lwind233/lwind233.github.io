---
title: 53 最大子数组和
date: 2026-02-28T22:21:00
tags:
  - 动态规划
  - 数组
  - 前缀和
categories:
  - 题解
  - hot100
---

### 前缀和解法

先求前缀和，然后遍历前缀和数组，问题转化为求max bSum[i]-bSum[j] ，i>j

每次计算当前前缀和与历史最小前缀和的差，然后更新历史最小前缀和

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] bSum = new int[nums.length+1];
        for(int i=1;i<=nums.length;i++){
            bSum[i] = bSum[i-1]+nums[i-1];
        }

        int minPre=bSum[0];
        int ans=Integer.MIN_VALUE;
        for(int i=1;i<=bSum.length-1;i++){
            ans = Math.max(ans,bSum[i]-minPre);
            minPre = Math.min(minPre,bSum[i]);
        }
    
        return ans;

    }
}
```

### 动态规划

dp[i]代表以i为结尾的最大字符串和
然后判断nums[i]和dp[i-1]+nums[i]的值
如果前者大，说明从i往前的子串和都是负贡献，不如从i重新开始，dp[i]=nums[i]
否则就带上历史子串
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int max = dp[0];
        
        for(int i=1;i<=nums.length-1;i++){
            dp[i] = nums[i]>nums[i]+dp[i-1]?nums[i]:dp[i-1]+nums[i];
            max = Math.max(max,dp[i]);
        }

        return max;
    }
}
```
