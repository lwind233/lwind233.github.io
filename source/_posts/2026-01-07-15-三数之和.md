---
title: 15 三数之和
date: 2026-01-07T13:44:00
tags:
  - 双指针
  - 数组
  - 哈希表
  - 回溯
categories:
  - 题解
  - 代码随想录
---
明明是二刷却完全没印象，最后绞尽脑汁用回溯勉强没超时

## 回溯

思路由两数之和推广而来，a+b+c=0，统计a+b，找0-a-b是否存在即可
问题可以转化为，依次取数组中的两个数，判断这里两个数之和的负数是否在数组里，同时解唯一

用哈希表统计数组中每个数字的个数，然后分两次循环遍历哈希表的键集合，每次取一个数字并减少其频数，判断两个键的和的负数是否在哈希表里。同时为了去重，强制让a<=b<=c，遍历完毕后恢复数字的频数

```java
class Solution {
    HashMap<Integer,Integer> set;


    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        set = new HashMap<>();
        for(int i=0;i<=nums.length-1;i++){
            set.put(nums[i],set.getOrDefault(nums[i],0)+1);
        }


        for(Integer key:set.keySet()){
            int t = set.get(key); 
            set.put(key,t-1);
            for(Integer nKey:set.keySet()){
                int c = set.get(nKey);
                set.put(nKey,c-1);
                if(c>0 && nKey>=key){
                    int sum = nKey+key;
                    if(set.containsKey(0-sum) && set.get(0-sum)>=1 && 0-sum>=nKey){
                        List<Integer> tmp = new ArrayList<>(Arrays.asList(key,nKey,0-sum));
                        result.add(tmp);
                    }
                }
                set.put(nKey,c);             
            }
            set.put(key,t);
        }


        return result;
    }
}
```

## 双指针

先给数组排序，然后对下标i，定义双指针left=i+1，right=length-1，这样自然满足之前的a<=b<=c的要求。

然后计算i+left+right的和是不是0，大于0的话向左移动right，小于0的话向右移动right，直到left和right相遇。

随后的问题是去重，当i递增时，i不应该跟自己刚刚遍历的元素一样，否则自然重复了。同时也要对left和right进行去重

```javastacktrace
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int left,right;
        List<List<Integer>> result = new ArrayList<>();
        for(int i=0;i<=nums.length-1-2;i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            left = i+1;
            right = nums.length-1;
            while(left<right){
                if(nums[i]+nums[left]+nums[right]>0) right--;
                else if(nums[i]+nums[left]+nums[right]<0) left++;
                else{
                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while(left<right && nums[right]==nums[right-1]) right--;
                    while(left<right && nums[left]==nums[left+1]) left++;
                    // 注意上面是去重，下面才是移动指针
                    right--;
                    left++;
                }
            }
        }
        return result;
    }
}
```
