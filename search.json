[{"title":"27 移除元素","url":"/posts/73c54e24.html","content":"<p>遍历一遍数组，一遍遍历一遍更新元素，同时维护一个偏移量，每有一个需要被移出的元素，偏移量就加一，最后偏移量就是被移除的元素数量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">removeElement</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> offset=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i+offset&lt;=l;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i+offset&lt;=l-<span class=\"number\">1</span> &amp;&amp; nums[i+offset]==val)&#123;</span><br><span class=\"line\">                offset++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i+offset&gt;=l)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nums[i] = nums[i+offset];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l-offset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过我的思路复杂了，还有更简单的实现方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">removeElement</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> offset=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=l-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]!=val)&#123;</span><br><span class=\"line\">                nums[offset] = nums[i];</span><br><span class=\"line\">                offset++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> offset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本身整个代码也是双指针的思想</p>\n","categories":["题解","代码随想录"],"tags":["数组","原地运算","双指针"]},{"title":"1 两数之和","url":"/posts/f647a04d.html","content":"<p>目标是找出a+b&#x3D;target，那么可以把a存入哈希表中，然后查找是否存在target-b这个键，如果存在说明有这个组合。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] twoSum(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer,Integer&gt; idxMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=nums.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            idxMap.put(nums[i],i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=nums.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> idxMap.getOrDefault(target-nums[i],-<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(idx!=-<span class=\"number\">1</span> &amp;&amp; idx!=i)&#123;</span><br><span class=\"line\">                result[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">                result[<span class=\"number\">1</span>] = idx;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","hot100"],"tags":["数组","哈希表"]},{"title":"142 环形链表2","url":"/posts/8483f257.html","content":"<p>经典算法，Floyd判圈算法</p>\n<p>先搞一个快指针，一个慢指针，步长分别为2和1</p>\n<ul>\n<li>步长不同的两个指针必然相遇，且两个指针相遇时，一定是在环上</li>\n<li>相遇点和起点等速的指针将在入口相遇</li>\n</ul>\n<p>为啥呢，第一点不太用证明，想想大概就能想明白，主要是第二点</p>\n<p>相遇点和起点的等速指针为什么会相遇？<br>假设相遇时慢指针走了s，则快指针走了2s，两者到达点a<br>那么让快指针重置回起点，两者等速走s。此时慢指针走了2s，也就是回到了点a，而快指针走了s，同样到达了点a。这样说明它们肯定会相遇，但点a未必是两个等速指针的初次相遇点。</p>\n<p>而且两者的相遇点肯定是在环上，因为慢指针不可能脱离环。</p>\n<p>但二者又是等速指针，还能在环上相遇，说明二者在点a之前就已经相遇了，也就是说当快指针刚进入环时就和慢指针相遇了，不然不可能前面还不相遇一到点a两个等速指针就相遇了。</p>\n<p>因此，两个等速指针首次相遇的位置就是环的入口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">detectCycle</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">tHead</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>();</span><br><span class=\"line\">        tHead.next = head;</span><br><span class=\"line\">        ListNode slow=tHead,fast=tHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(fast==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(fast==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(slow==fast) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fast = tHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(slow==fast) <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>快指针一定可以追上慢指针，那样直接算两个指针的路程差就可以找出入口了，那样也可以做，不过感觉还是这个方法更容易理解</p>\n","categories":["题解","代码随想录"],"tags":["双指针","链表"]},{"title":"203 移除链表元素","url":"/posts/addc11d4.html","content":"<p>一个指针指向当前节点的父节点，一个指针指向当前节点</p>\n<p>当当前节点的值等于目标值时，往下遍历链表，找到一个值不为目标值的节点，让父节点指向该节点</p>\n<p>然后更新父节点指针和当前节点指针的位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">removeElements</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">tmpHead</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>();</span><br><span class=\"line\">        tmpHead.next = head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> tmpHead;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> pre.next;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">null</span> &amp;&amp; cur.val==val)&#123;</span><br><span class=\"line\">                cur = cur.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre.next=cur;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur==<span class=\"literal\">null</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                pre=cur;</span><br><span class=\"line\">                cur=pre.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmpHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["双指针","链表"]},{"title":"704 二分查找","url":"/posts/bec715a6.html","content":"<p>二分感觉没啥好说的，单调数列，一个左指针一个右指针，中间值直接取二者平均值，然后遍历直到找到目标即可<br>（如果数列长度过大考虑l+r-l&#x2F;2防止溢出）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">search</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (right+left)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left&lt;=right)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid]&gt;target)&#123;</span><br><span class=\"line\">                right = mid-<span class=\"number\">1</span>;</span><br><span class=\"line\">                mid = (right+left)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid]&lt;target)&#123;</span><br><span class=\"line\">                left = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">                mid = (right+left)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid]==target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组","二分"]},{"title":"202 快乐数","url":"/posts/3e82ed40.html","content":"<p>用哈希表记录过去出现过的数字，如果该数字出现过说明进入了循环，也就不可能是快乐数。否则自然会变成1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isHappy</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(path.containsKey(n)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            path.put(n,<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> n;</span><br><span class=\"line\">            n = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> tn;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(tmp!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                tn = tmp%<span class=\"number\">10</span>;</span><br><span class=\"line\">                tmp = tmp/<span class=\"number\">10</span>;</span><br><span class=\"line\">                n+=tn*tn;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["哈希表"]},{"title":"19 删除链表的倒数第n个节点","url":"/posts/4d6426d7.html","content":"<p>拿一个指针当探头</p>\n<p>两个指针间隔n个距离</p>\n<p>当探头指到链表尾部时，前面的指针刚好是待删除节点的父节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">tHead</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>();</span><br><span class=\"line\">        tHead.next = head;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">cnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> tHead;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cnt&lt;n)&#123;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            pre = pre.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre.next = pre.next==<span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : pre.next.next;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tHead.next;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["双指针","链表"]},{"title":"206 反转链表","url":"/posts/4faca935.html","content":"<h2 id=\"递归解法\"><a href=\"#递归解法\" class=\"headerlink\" title=\"递归解法\"></a>递归解法</h2><p>每层传入当前节点和当前节点的父节点</p>\n<p>如果当前节点的下一个节点是null，也就是尾节点</p>\n<p>那当前节点就是新的头结点</p>\n<p>然后对每一层，让当前节点指向父节点</p>\n<p>最后将原始的头结点指向null</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    ListNode fin=<span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">reverseList</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head==<span class=\"literal\">null</span> || head.next==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        traversal(head,head.next);</span><br><span class=\"line\">        head.next=<span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traversal</span><span class=\"params\">(ListNode pre, ListNode cur)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur.next!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            traversal(cur,cur.next);</span><br><span class=\"line\">            cur.next=pre;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            fin=cur;</span><br><span class=\"line\">            cur.next=pre;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"迭代解法\"><a href=\"#迭代解法\" class=\"headerlink\" title=\"迭代解法\"></a>迭代解法</h2><p>还是经典维护双指针，或者说三指针，记录好当前节点的下一个节点，然后让当前节点指向父节点，最后更新父节点指针和当前节点指针的位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">reverseList</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        ListNode tmp;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            tmp = cur.next;</span><br><span class=\"line\">            cur.next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["双指针","链表","递归"]},{"title":"454 四数相加2","url":"/posts/41ec162b.html","content":"<p>就是两数之和，不过复杂度高了一点，把前两个数组的和当键，查target-n3-n4是否存在，存在多少个。没啥需要讲的，看代码就完事了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">fourSumCount</span><span class=\"params\">(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2, <span class=\"type\">int</span>[] nums3, <span class=\"type\">int</span>[] nums4)</span> &#123;</span><br><span class=\"line\">        HashMap&lt;Integer,Integer&gt; map12 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        HashMap&lt;Integer,Integer&gt; map34 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=nums1.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=nums2.length-<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">                map12.put(nums1[i]+nums2[j], map12.getOrDefault(nums1[i]+nums2[j],<span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> result=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=nums3.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=nums4.length-<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(map12.containsKey(<span class=\"number\">0</span>-nums3[i]-nums4[j]))&#123;</span><br><span class=\"line\">                    result+=map12.get(<span class=\"number\">0</span>-nums3[i]-nums4[j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组","哈希表"]},{"title":"24 两两交换链表中的节点","url":"/posts/86f95108.html","content":"<p>仍然是双指针，一个指针指向上一个节点对的尾节点，另一个指针指向当前节点对的头结点</p>\n<p>注意好赋值顺序即可，先用tmp存一下尾节点的下一个节点的位置，然后更新上一个节点对尾节点的下一节点，然后顺着往下更新当前节点对更新后的尾节点，最后调整当前尾节点的next值。最后更新pre和cur</p>\n<p>如果cur.next是空值，也就是到链表尾部了（链表节点数量为奇数），直接退出</p>\n<p>画图的话解释的会更方便，但这里不方便画图，看代码吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">swapPairs</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head==<span class=\"literal\">null</span> || head.next==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">tHead</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>();</span><br><span class=\"line\">        tHead.next = head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> tHead;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> tHead.next;</span><br><span class=\"line\">        ListNode tmp;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur.next==<span class=\"literal\">null</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            tmp = cur.next.next;</span><br><span class=\"line\">            pre.next = cur.next;</span><br><span class=\"line\">            cur.next.next = cur;</span><br><span class=\"line\">            cur.next = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["双指针","链表"]},{"title":"59 螺旋矩阵2","url":"/posts/1850a0c5.html","content":"<p>有一说一，没啥好讲的，就是模拟一下</p>\n<p>需要注意的点就是先移动，后判断下一步移动方向</p>\n<p>初始位置可以放在矩阵外，方便统一移动方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[][] generateMatrix(<span class=\"type\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n][n];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">dire</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> j=-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">total</span> <span class=\"operator\">=</span> n*n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cnt&lt;total)&#123;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dire==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                result[i][j]=cnt;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j==n-<span class=\"number\">1</span> || result[i][j+<span class=\"number\">1</span>]!=<span class=\"number\">0</span>) dire=<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dire==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                result[i][j]=cnt;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i==n-<span class=\"number\">1</span> || result[i+<span class=\"number\">1</span>][j]!=<span class=\"number\">0</span>) dire=<span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dire==<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">                result[i][j]=cnt;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j==<span class=\"number\">0</span> || result[i][j-<span class=\"number\">1</span>]!=<span class=\"number\">0</span>) dire=<span class=\"number\">3</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dire==<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">                result[i][j]=cnt;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span> || result[i-<span class=\"number\">1</span>][j]!=<span class=\"number\">0</span>) dire=<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组"]},{"title":"242 有效的字母异位词","url":"/posts/b86aad76.html","content":"<p>为两个字符串建立哈希表，比较哈希表是否一致即可</p>\n<p>节省内存的话可以只建立一个哈希表，第一次建立时统计字符频数，第二次减去字符频数，然后看哈希表内是不是每个键都是0</p>\n<p>注意Integer比较时要用equals而不能用&#x3D;&#x3D;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isAnagram</span><span class=\"params\">(String s, String t)</span> &#123;</span><br><span class=\"line\">        HashMap&lt;Character,Integer&gt; hashMapS = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        HashMap&lt;Character,Integer&gt; hashMapT = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sLen</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">tLen</span> <span class=\"operator\">=</span> t.length();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sLen!=tLen) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=sLen-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            hashMapS.put(s.charAt(i),hashMapS.getOrDefault(s.charAt(i),<span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">            hashMapT.put(t.charAt(i),hashMapT.getOrDefault(t.charAt(i),<span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Character c : hashMapS.keySet())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!hashMapS.get(c).equals(hashMapT.getOrDefault(c,-<span class=\"number\">1</span>))) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["哈希表"]},{"title":"349 两个数组的交集","url":"/posts/b038c7ff.html","content":"<p>建个哈希表，或者用set都可以解决，没啥好说的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] intersection(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer,Integer&gt; map1 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        HashMap&lt;Integer,Integer&gt; map2 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=nums1.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            map1.put(nums1[i],<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=nums2.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            map2.put(nums2[i],<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Integer&gt; resultList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Integer key:map1.keySet())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map2.containsKey(key)) resultList.add(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> resultList.stream().mapToInt(Integer::intValue).toArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组","哈希表"]},{"title":"383 赎金信","url":"/posts/c5f03ab7.html","content":"<p>做法也比较简单，就是比较magazine的哈希表是不是比ransomNote“大”就可以</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canConstruct</span><span class=\"params\">(String ransomNote, String magazine)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] map = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lenM</span> <span class=\"operator\">=</span> magazine.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=lenM-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>+magazine.charAt(i)-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">            map[idx]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lenR</span> <span class=\"operator\">=</span> ransomNote.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=lenR-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>+ransomNote.charAt(i)-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">            map[idx]--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map[idx]&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组","哈希表"]},{"title":"209 长度最小的子数组","url":"/posts/c547613c.html","content":"<p>维护一个滑动窗口，窗口从左向右遍历，每当右边界向右拓展一个新元素时，左边界也尽量向右收缩，同时满足窗口内元素大于目标值的要求</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, <span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> minLen=len;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> right=<span class=\"number\">0</span>;right&lt;=len-<span class=\"number\">1</span>;right++)&#123;</span><br><span class=\"line\">            sum = sum+nums[right];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum&gt;=target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> nums[left];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sum-tmp&gt;=target)&#123;</span><br><span class=\"line\">                        sum-=tmp;</span><br><span class=\"line\">                        left++;</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">tmpLen</span> <span class=\"operator\">=</span> right-left+<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmpLen&lt;minLen)&#123;</span><br><span class=\"line\">                    minLen = tmpLen;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum&lt;target) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> minLen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组","滑动窗口"]},{"title":"28 找出字符串中第一个匹配的下标","url":"/posts/f1708c7e.html","content":"<p>暴力解法就不写了</p>\n<p>权当背kmp算法了</p>\n<p>kmp算法的基本思想就是为模式字符串维护一个最大公共前后缀表</p>\n<p>什么是公共前后缀，就是相同的前后缀，前缀是从开头开始，不包括最后一个字符的字符串，后缀是</p>\n","categories":["题解","代码随想录"],"tags":["字符串"]},{"title":"15 三数之和","url":"/posts/267ca72f.html","content":"<p>明明是二刷却完全没印象，最后绞尽脑汁用回溯勉强没超时</p>\n<h2 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h2><p>思路由两数之和推广而来，a+b+c&#x3D;0，统计a+b，找0-a-b是否存在即可<br>问题可以转化为，依次取数组中的两个数，判断这里两个数之和的负数是否在数组里，同时解唯一</p>\n<p>用哈希表统计数组中每个数字的个数，然后分两次循环遍历哈希表的键集合，每次取一个数字并减少其频数，判断两个键的和的负数是否在哈希表里。同时为了去重，强制让a&lt;&#x3D;b&lt;&#x3D;c，遍历完毕后恢复数字的频数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    HashMap&lt;Integer,Integer&gt; set;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">threeSum</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=nums.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            set.put(nums[i],set.getOrDefault(nums[i],<span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Integer key:set.keySet())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> set.get(key);</span><br><span class=\"line\">            set.put(key,t-<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Integer nKey:set.keySet())&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> set.get(nKey);</span><br><span class=\"line\">                set.put(nKey,c-<span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(c&gt;<span class=\"number\">0</span> &amp;&amp; nKey&gt;=key)&#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> nKey+key;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(set.containsKey(<span class=\"number\">0</span>-sum) &amp;&amp; set.get(<span class=\"number\">0</span>-sum)&gt;=<span class=\"number\">1</span> &amp;&amp; <span class=\"number\">0</span>-sum&gt;=nKey)&#123;</span><br><span class=\"line\">                        List&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(Arrays.asList(key,nKey,<span class=\"number\">0</span>-sum));</span><br><span class=\"line\">                        result.add(tmp);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                set.put(nKey,c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set.put(key,t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><p>先给数组排序，然后对下标i，定义双指针left&#x3D;i+1，right&#x3D;length-1，这样自然满足之前的a&lt;&#x3D;b&lt;&#x3D;c的要求。</p>\n<p>然后计算i+left+right的和是不是0，大于0的话向左移动right，小于0的话向右移动right，直到left和right相遇。</p>\n<p>随后的问题是去重，当i递增时，i不应该跟自己刚刚遍历的元素一样，否则自然重复了。同时也要对left和right进行去重</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">threeSum</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"type\">int</span> left,right;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=nums.length-<span class=\"number\">1</span>-<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; nums[i]==nums[i-<span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            left = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">            right = nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(left&lt;right)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i]+nums[left]+nums[right]&gt;<span class=\"number\">0</span>) right--;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]+nums[left]+nums[right]&lt;<span class=\"number\">0</span>) left++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class=\"number\">1</span>]) right--;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class=\"number\">1</span>]) left++;</span><br><span class=\"line\">                    <span class=\"comment\">// 注意上面是去重，下面才是移动指针</span></span><br><span class=\"line\">                    right--;</span><br><span class=\"line\">                    left++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组","双指针","哈希表","回溯"]},{"title":"344 反转字符串","url":"/posts/17e590f3.html","content":"<p>维护左右指针，一个初始化为字符串头部，另一个初始化为字符串尾部，然后交换两个指针指向的元素，并向内移动两个双指针</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reverseString</span><span class=\"params\">(<span class=\"type\">char</span>[] s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right=s.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">char</span> tmp;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left&lt;=right)&#123;</span><br><span class=\"line\">            tmp = s[left];</span><br><span class=\"line\">            s[left]=s[right];</span><br><span class=\"line\">            s[right]=tmp;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组","双指针"]},{"title":"18 四数之和","url":"/posts/36062318.html","content":"<p>理论上我那个回溯也可以做，但我懒得写了</p>\n<p>就是三数之和多套了一层循环，注意有个用例可能导致四数之和超过int上限，要改用long，另外注意下第二个元素的去重规则</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">fourSum</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> left,right;</span><br><span class=\"line\">        <span class=\"type\">long</span> sum;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=nums.length-<span class=\"number\">1</span>-<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; nums[i]==nums[i-<span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=nums.length-<span class=\"number\">1</span>-<span class=\"number\">2</span>;j++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 注意一下这里</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j&gt;i+<span class=\"number\">1</span> &amp;&amp; nums[j]==nums[j-<span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                left = j+<span class=\"number\">1</span>;</span><br><span class=\"line\">                right = nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(left&lt;right)&#123;</span><br><span class=\"line\">                    sum = (<span class=\"type\">long</span>)nums[i]+(<span class=\"type\">long</span>)nums[j]+(<span class=\"type\">long</span>)nums[left]+(<span class=\"type\">long</span>)nums[right];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sum&gt;target) right--;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum&lt;target) left++;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class=\"number\">1</span>]) left++;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class=\"number\">1</span>]) right--;</span><br><span class=\"line\">                        left++;</span><br><span class=\"line\">                        right--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组","双指针"]},{"title":"面试题 链表相交","url":"/posts/f453a69e.html","content":"<p>先测量两个链表的长度，求出长度差，然后在距链表尾相同距离的地方开始同时遍历两个链表，当两个指针指向相同的位置时，即是交点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> lenA=<span class=\"number\">0</span>, lenB=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> headA;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            lenA++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        cur = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            lenB++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">longList</span> <span class=\"operator\">=</span> lenA&gt;=lenB ? headA : headB;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">shortList</span> <span class=\"operator\">=</span> lenA&gt;=lenB ? headB : headA;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">diff</span> <span class=\"operator\">=</span> Math.abs(lenA-lenB);</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">longCur</span> <span class=\"operator\">=</span> longList;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">shortCur</span> <span class=\"operator\">=</span> shortList;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=diff;i++)&#123;</span><br><span class=\"line\">            longCur = longCur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(longCur!=<span class=\"literal\">null</span> &amp;&amp; longCur!=shortCur)&#123;</span><br><span class=\"line\">            longCur = longCur.next;</span><br><span class=\"line\">            shortCur = shortCur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> longCur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["链表"]},{"title":"151 翻转字符串里的单词","url":"/posts/9597f865.html","content":"<p>用双指针记录一下每个单词的头尾，倒序遍历字符串将所有的单词挨个提取出来即可</p>\n<p>java没法修改字符串所以没法做原地算法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">reverseWords</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">st</span> <span class=\"operator\">=</span> len-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ed</span> <span class=\"operator\">=</span> len-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(st&gt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.charAt(ed)==<span class=\"string\">&#x27; &#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(ed&gt;=<span class=\"number\">0</span> &amp;&amp; s.charAt(ed)==<span class=\"string\">&#x27; &#x27;</span>) ed--;</span><br><span class=\"line\">                st = ed;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(st==-<span class=\"number\">1</span> &amp;&amp; s.charAt(<span class=\"number\">0</span>)==<span class=\"string\">&#x27; &#x27;</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(st&gt;=<span class=\"number\">0</span> &amp;&amp; s.charAt(st)!=<span class=\"string\">&#x27; &#x27;</span>) st--;</span><br><span class=\"line\">            result.append(s.substring(st+<span class=\"number\">1</span>,ed+<span class=\"number\">1</span>));</span><br><span class=\"line\">            result.append(<span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\">            ed = st;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">tmpResult</span> <span class=\"operator\">=</span> result.toString();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmpResult.substring(<span class=\"number\">0</span>,tmpResult.length()-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["双指针","字符串"]},{"title":"大模型应用开发入门（三）RAG引入","url":"/posts/fb760a05.html","content":"<p>RAG的基本流程</p>\n<ul>\n<li>文档切割与文档向量化</li>\n<li>计算问题与文档的相似度</li>\n<li>返回文档块</li>\n</ul>\n<p>主要实现优化点在于如何进行文档切割</p>\n<h2 id=\"文档切割\"><a href=\"#文档切割\" class=\"headerlink\" title=\"文档切割\"></a>文档切割</h2><p>由于实际的文档格式繁多且复杂，导致RAG的文档切割策略多种多样，不存在一个可以完全适配所有文档格式的切分策略。有时候会使用多个策略相结合的方式来提高文档的查询准确率，减少幻觉</p>\n<p>分块的主要方法有</p>\n<ul>\n<li>朴素分块</li>\n<li>结构分块</li>\n<li>语义分块</li>\n<li>智能体分块</li>\n</ul>\n<p>各种分块方法之间并非是对立的，实际运用中可能会采用多粒度分块方法，进行多次分块，每次分块采用不同的分块方法。</p>\n<h3 id=\"朴素分块\"><a href=\"#朴素分块\" class=\"headerlink\" title=\"朴素分块\"></a>朴素分块</h3><p>朴素分块方法主要有固定长度分块以及按分隔符分块等。</p>\n<p>固定分块可能会导致上下文断裂，为了解决这个问题，可以引入重叠（overleap）。<br>按分隔符分块包括按句分块、按段分块以及按页分块等。</p>\n<h3 id=\"结构分块\"><a href=\"#结构分块\" class=\"headerlink\" title=\"结构分块\"></a>结构分块</h3><p>比如markdown文档这种结构区分很明显的文档，可以按各个标题进行分割。<br>或者json这种格式的文档，也可以切出各个部分的内容。</p>\n<h3 id=\"语义分块\"><a href=\"#语义分块\" class=\"headerlink\" title=\"语义分块\"></a>语义分块</h3><p>计算各个部分的语义相似度，当两个块之间的余弦相似度过低时分为两块</p>\n<h3 id=\"智能体分块\"><a href=\"#智能体分块\" class=\"headerlink\" title=\"智能体分块\"></a>智能体分块</h3><p>让大模型判断文档到哪个部分分块<br>资源消耗量极大，只适合高价值的少量文档</p>\n<h2 id=\"相似度计算\"><a href=\"#相似度计算\" class=\"headerlink\" title=\"相似度计算\"></a>相似度计算</h2><h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><h3 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h3><h3 id=\"多召回\"><a href=\"#多召回\" class=\"headerlink\" title=\"多召回\"></a>多召回</h3>","categories":["大模型应用开发"],"tags":["agent","rag","springai"]},{"title":"977 有序数组的平方","url":"/posts/7ece436.html","content":"<p>原数组的特点是，其绝对值（或平方）先递减后递增，也就是最大值在两侧最小值在中间。</p>\n<p>用双指针从两侧遍历整个数组，就可以从大到小遍历完整个数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] sortedSquares(<span class=\"type\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left,right;</span><br><span class=\"line\">        left=<span class=\"number\">0</span>;</span><br><span class=\"line\">        right = nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"type\">int</span> count=nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left&lt;=right)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[left]*nums[left]&gt;=nums[right]*nums[right])&#123;</span><br><span class=\"line\">                result[count] = nums[left]*nums[left];</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                result[count] = nums[right]*nums[right];</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组","双指针"]},{"title":"暂存","url":"/posts/e76dd3a4.html","content":"<p>存点杂知识，后面再整理</p>\n<h2 id=\"Spring集合注入\"><a href=\"#Spring集合注入\" class=\"headerlink\" title=\"Spring集合注入\"></a>Spring集合注入</h2><p><code>Map&lt;String, T&gt;</code> 的格式会让spring扫描所有符合t的bean，然后注入到这个map里</p>\n<p><code>List&lt;T&gt;</code> 也会有类似的效果</p>\n","categories":["杂项"]},{"title":"MCP vs Function calling","url":"/posts/94a39dd7.html","content":"<p>问了半天GPT，算是简单弄明白了两者之间的关联</p>\n<h2 id=\"Function-calling\"><a href=\"#Function-calling\" class=\"headerlink\" title=\"Function calling\"></a>Function calling</h2><p>function calling侧重于大模型本身的能力，大模型生成指定json格式的输出以调用其他工具，这基本上就是function calling。</p>\n<p>function calling的鲁棒性源自三个方面</p>\n<ol>\n<li>模型权重本身性能表现好，能够理解如何生成指定的json格式输出。</li>\n<li>大模型部署的推理平台（如ollama）可以通过调整logits来强制大模型按照指定格式输出。</li>\n<li>MCP client会对大模型输出的格式进行检查，如果出现错误会提示大模型重新输出</li>\n</ol>\n<h2 id=\"MCP\"><a href=\"#MCP\" class=\"headerlink\" title=\"MCP\"></a>MCP</h2><p>MCP（model context protocol）模型上下文协议，本质上是一种协议，用于实现大模型和工具之间的解耦合。</p>\n<p>有了MCP协议，再也不用硬编码来告诉大模型有哪些工具可以调用，并费劲去解析大模型的输出、并根据输出去调用工具函数。</p>\n<p>而是去根据可调用的工具去编写MCP server，MCP server负责告诉MCP client自己有什么工具可以被调用，它们的功能是什么，如何调用以及调用的结果格式是什么。MCP client会在大模型开始推理的时候将这些信息自动注入到prompt里。</p>\n<p>这样大模型和需要调用的工具可以自由的调换，而不必重新编写大量的适配代码</p>\n<p>相当于从用胶水粘木头到用榫卯拼接木头</p>\n","categories":["大模型应用开发"],"tags":["mcp","function calling"]},{"title":"右旋字符串","url":"/posts/743aa8ac.html","content":"<p>这个题力扣上没有</p>\n<p>思路就是将字符串向右移动k位，相当于将后面k个元素移动到开头</p>\n<p>直接反转整个字符串就可以做到将后面k个字符放到开头，但是这个顺序是颠倒的，此时再分别反转前k个字符和后n-k个字符即可</p>\n<p>不写具体实现了，记记思路</p>\n","categories":["题解","代码随想录"],"tags":["双指针","字符串"]},{"title":"大模型应用开发入门（四）MCP协议","url":"/posts/fe69269d.html","content":"<p>占位符</p>\n","categories":["大模型应用开发"],"tags":["agent","springai","mcp"]},{"title":"541 反转字符串2","url":"/posts/5eaf0409.html","content":"<p>我认为这道题没啥记得必要，但做都做了</p>\n<p>用rev记录当前状态，每k个字符后判断是否要反转，要反转就从尾到头添加字符，否则从头到尾添加字符，最后处理一下尾部。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">reverseStr</span><span class=\"params\">(String s, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        StringBuilder tmp;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">rev</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=s.length()-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(count==k &amp;&amp; rev)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=k-<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">                    result.append(s.charAt(i-j));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                rev = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                count=<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(count==k &amp;&amp; !rev)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=k-<span class=\"number\">1</span>;j&gt;=<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">                    result.append(s.charAt(i-j));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                rev = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                count=<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rev) <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=count-<span class=\"number\">1</span>;j++) result.append(s.charAt(s.length()-<span class=\"number\">1</span>-j));</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=count-<span class=\"number\">1</span>;j&gt;=<span class=\"number\">0</span>;j--) result.append(s.charAt(s.length()-<span class=\"number\">1</span>-j));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["字符串"]},{"title":"大模型应用开发入门（一）Agent基本调用","url":"/posts/b0393815.html","content":"<h2 id=\"agent注册\"><a href=\"#agent注册\" class=\"headerlink\" title=\"agent注册\"></a>agent注册</h2><p>用于和大模型api交互的类都继承了ChatClient接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean(&quot;deepseek-chat&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ChatClient <span class=\"title function_\">deepseekChatClient</span><span class=\"params\">(DeepSeekChatModel deepSeekChatModel)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ChatClient.create(deepSeekChatModel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"agent调用\"><a href=\"#agent调用\" class=\"headerlink\" title=\"agent调用\"></a>agent调用</h2><p>单轮对话中，可以直接链式调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ChatClient agent;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">ChatResponse</span> <span class=\"variable\">output</span> <span class=\"operator\">=</span> agent.call()</span><br><span class=\"line\">                .prompt()</span><br><span class=\"line\">                .user()</span><br><span class=\"line\">                .call()</span><br><span class=\"line\">                .chatResponse();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">AssistantMessage</span> <span class=\"variable\">assistant</span> <span class=\"operator\">=</span> output</span><br><span class=\"line\">                             .getResult()</span><br><span class=\"line\">                             .getOutput()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ChatClient交互的输入和输出都要依赖Message接口的实现类</p>\n<p>而多轮对话中，为了使得模型有上下文记忆，需要其存储先前的消息并再次发送给大模型</p>\n<h3 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h3><p>消息可以分为四类</p>\n<ul>\n<li>用户消息 UserMessage</li>\n<li>大模型消息 AssistantMessage</li>\n<li>系统提示 SystemMessage</li>\n<li>工具消息 ToolResponseMessage</li>\n</ul>\n<h3 id=\"聊天记忆\"><a href=\"#聊天记忆\" class=\"headerlink\" title=\"聊天记忆\"></a>聊天记忆</h3><p>ChatMemory 接口定义了聊天对话记忆的存储机制，提供添加消息、检索消息及清空对话历史的方法。</p>\n<p>常用方法</p>\n<ul>\n<li>add(String, Message) 指定会话id，添加消息</li>\n<li>get(String) 根据指定的会话id按添加顺序返回消息列表</li>\n<li>clear(String) 根据指定的会话id清空消息列表</li>\n</ul>\n<h4 id=\"MessageWindowChatMemory\"><a href=\"#MessageWindowChatMemory\" class=\"headerlink\" title=\"MessageWindowChatMemory\"></a>MessageWindowChatMemory</h4><p>MessageWindowChatMemory 维护固定容量的消息窗口（默认 20 条）。当消息超限时，自动移除较早的对话消息（始终保留系统消息）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MessageWindowChatMemory</span> <span class=\"variable\">memory</span> <span class=\"operator\">=</span> MessageWindowChatMemory.builder()</span><br><span class=\"line\">    .maxMessages(<span class=\"number\">10</span>)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">此为 Spring AI 自动配置 ChatMemory Bean 时采用的默认消息类型。</span><br></pre></td></tr></table></figure>\n\n<p>可以将历史交互统一塞入到chatMemory中，然后通过调用时的prompt方法来为模型提供上下文记忆</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Prompt</span> <span class=\"variable\">prompt</span> <span class=\"operator\">=</span> Prompt.builder()</span><br><span class=\"line\">        .messages(chatMemory.get(sessionId))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"><span class=\"type\">ChatResponse</span> <span class=\"variable\">output</span> <span class=\"operator\">=</span> agent.call()</span><br><span class=\"line\">        .prompt(prompt)</span><br><span class=\"line\">        .call()</span><br><span class=\"line\">        .chatResponse();</span><br></pre></td></tr></table></figure>\n\n<p>有了这些，就可以实现一个具备多轮对话功能的agent了</p>\n<p>还可以考虑将大模型的会话记忆入库使其持久化，实现长期记忆</p>\n","categories":["大模型应用开发"],"tags":["agent","springai","java"]},{"title":"150 逆波兰表达式","url":"/posts/e77c394a.html","content":"<p>遇到整数就入栈，遇到运算符就出两个整数，然后将结果入栈</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">evalRPN</span><span class=\"params\">(String[] tokens)</span> &#123;</span><br><span class=\"line\">        Stack&lt;Integer&gt; nums = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=tokens.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tokens[i].equals(<span class=\"string\">&quot;+&quot;</span>) || tokens[i].equals(<span class=\"string\">&quot;-&quot;</span>) || tokens[i].equals(<span class=\"string\">&quot;*&quot;</span>) || tokens[i].equals(<span class=\"string\">&quot;/&quot;</span>))&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">num2</span> <span class=\"operator\">=</span> nums.pop();</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">num1</span> <span class=\"operator\">=</span> nums.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tokens[i].equals(<span class=\"string\">&quot;+&quot;</span>)) nums.push(num1+num2);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tokens[i].equals(<span class=\"string\">&quot;-&quot;</span>)) nums.push(num1-num2);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tokens[i].equals(<span class=\"string\">&quot;*&quot;</span>)) nums.push(num1*num2);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tokens[i].equals(<span class=\"string\">&quot;/&quot;</span>)) nums.push(num1/num2);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                nums.push(Integer.parseInt(tokens[i]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["栈与队列"]},{"title":"239 滑动窗口最大值","url":"/posts/f7491bcb.html","content":"<h2 id=\"堆解法-延时删除\"><a href=\"#堆解法-延时删除\" class=\"headerlink\" title=\"堆解法&#x2F;延时删除\"></a>堆解法&#x2F;延时删除</h2><p>将值和下标存储进最大堆里，然后移动窗口，一边移动将新元素加入堆中，并判断当前堆的最大值是否在窗口里，如果不在就从堆中弹出，然后将当前窗口的最大值写入结果数组里</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Item</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> value;</span><br><span class=\"line\">        <span class=\"type\">int</span> idx;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Item</span><span class=\"params\">(<span class=\"type\">int</span> value, <span class=\"type\">int</span> idx)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.idx = idx;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] maxSlidingWindow(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        PriorityQueue&lt;Item&gt; pq = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(<span class=\"number\">1</span>,(a,b)-&gt;(b.value-a.value));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">Item</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Item</span>(nums[i-<span class=\"number\">1</span>],i-<span class=\"number\">1</span>);</span><br><span class=\"line\">            pq.offer(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length-k+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i+k-<span class=\"number\">1</span>&lt;=nums.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">Item</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Item</span>(nums[i+k-<span class=\"number\">1</span>],i+k-<span class=\"number\">1</span>);</span><br><span class=\"line\">            pq.offer(tmp);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(pq.peek().idx&lt;i) pq.poll();</span><br><span class=\"line\">            result[i] = pq.peek().value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单调队列解法\"><a href=\"#单调队列解法\" class=\"headerlink\" title=\"单调队列解法\"></a>单调队列解法</h2><p>思路和堆解法类似，改用单调队列，单调队列内元素严格递减，每当新元素入队时，所有比它老的元素而且比它小的元素就再也不可能是最大值了，因此直接删除<br>当窗口移动出的最大值刚好与当前的最大值一致时，弹出单调队列的最大值<br>每移动一次窗口，向结果数组写入一次当前单调队列的最大值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] maxSlidingWindow(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        Deque&lt;Integer&gt; monoStack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length-k+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(monoStack.isEmpty())&#123;</span><br><span class=\"line\">                monoStack.offer(nums[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!monoStack.isEmpty() &amp;&amp; monoStack.peekLast()&lt;nums[i-<span class=\"number\">1</span>]) monoStack.pollLast();</span><br><span class=\"line\">            monoStack.offer(nums[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i+k-<span class=\"number\">1</span>&lt;=nums.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> nums[i+k-<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!monoStack.isEmpty() &amp;&amp; monoStack.peekLast()&lt;tmp) monoStack.pollLast();</span><br><span class=\"line\">            monoStack.offer(tmp);</span><br><span class=\"line\">            result[i] = monoStack.peekFirst();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] == monoStack.peekFirst()) monoStack.pollFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组","滑动窗口","栈与队列","堆","单调队列"]},{"title":"27 移除元素","url":"/posts/73c54e24.html","content":"<p>遍历数组，记录offset，offset代表当前位置跳过了多少个等于val的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">removeElement</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> offset=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> len=nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=len-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i+offset&lt;=len-<span class=\"number\">1</span> &amp;&amp; nums[i+offset]==val)&#123;</span><br><span class=\"line\">                offset++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(offset+i&gt;len-<span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            nums[i] = nums[i+offset];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len-offset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组"]},{"title":"大模型应用开发入门（二）工具调用","url":"/posts/b55abc90.html","content":"<h2 id=\"工具注册\"><a href=\"#工具注册\" class=\"headerlink\" title=\"工具注册\"></a>工具注册</h2><p>通过@Tool注解就可以轻松的将某个方法注册为工具类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Tool(name = &quot;getDate&quot;, description = &quot;获取当前的日期&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getDate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring AI 将自动为 @Tool 注解方法的输入参数生成 JSON Schema。该 Schema 供模型理解如何调用工具及准备工具请求。</p>\n<h2 id=\"工具传入\"><a href=\"#工具传入\" class=\"headerlink\" title=\"工具传入\"></a>工具传入</h2><p>最终使用的工具是ToolCallBack的实现类，经过注解的工具需要转换为ToolCallBack才可以被调用。</p>\n<p>可利用MethodToolCallbackProvider类，解析多个工具类中注解了Tool的方法，将其转换为ToolCallBack数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ToolCallback[] toolCallbacks = MethodToolCallbackProvider.builder()</span><br><span class=\"line\">        .toolObjects(cityTool, dateTool, weatherTool)</span><br><span class=\"line\">        .build()</span><br><span class=\"line\">        .getToolCallbacks();</span><br></pre></td></tr></table></figure>\n\n<p>然后在chatClient调用时，将其传入<code>toolCallbacks</code>方法即可</p>\n<h2 id=\"工具解析与调用\"><a href=\"#工具解析与调用\" class=\"headerlink\" title=\"工具解析与调用\"></a>工具解析与调用</h2><p>使用默认行为时，Spring AI 会自动拦截模型的工具调用请求，执行工具并将结果返回模型。这些操作均由各 <code>ChatModel</code> 实现通过 <code>ToolCallingManager</code> 透明完成。</p>\n<p>若想自行进行控制，需要将 <code>ToolCallingChatOptions</code> 的 <br><code>internalToolExecutionEnabled</code> 属性设为 <code>false</code>。该参数需要传入prompt的<code>chatOptions</code></p>\n<p>此时，在通过调用chatClient获取到ChatResponse后，需要使用ToolCallingManager来执行工具调用请求</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ToolExecutionResult</span> <span class=\"variable\">toolExecutionResult</span> <span class=\"operator\">=</span> toolCallingManager.executeToolCalls(prompt，lastChatResponse);</span><br><span class=\"line\"><span class=\"comment\">// prompt应包含历史消息，同时要确保lastChatResponse中含有ToolCalls请求</span></span><br><span class=\"line\">chatMemory.clear(sessionId);        </span><br><span class=\"line\">chatMemory.add(sessionId,toolExecutionResult.conversationHistory());</span><br></pre></td></tr></table></figure>\n\n<p>当大模型认为自己已经获取到了足够的信息时，其回复的消息中ToolCalls将会为空，可以据此判断当前对话是否可以结束。</p>\n","categories":["大模型应用开发"],"tags":["agent","springai","java"]},{"title":"101 对称二叉树","url":"/posts/8170a206.html","content":"<p>同时进行两个前序遍历，其中一个顺序是中左右，另一个是中右左，然后比较两个遍历的结果是否一致</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> traversal(root.left,root.right);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">traversal</span><span class=\"params\">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left==<span class=\"literal\">null</span> &amp;&amp; right !=<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left!=<span class=\"literal\">null</span> &amp;&amp; right ==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right==<span class=\"literal\">null</span> &amp;&amp; left==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right.val!=left.val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> traversal(left.left,right.right) &amp;&amp; traversal(left.right,right.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用层序遍历也可以做，套层序遍历的模版，判断每一层的节点是不是回文字符串即可，具体实现代码不写了</p>\n","categories":["题解","代码随想录"],"tags":["递归","二叉树","树的遍历"]},{"title":"347 前k个高频元素","url":"/posts/eb666b7b.html","content":"<p>利用一个哈希表统计各个数字出现的频数，然后维护一个大小为k的小根堆，将哈希表中所有的键往里面存一遍，最后将小根堆里的元素弹出到结果数组里。</p>\n<p>真幽默，我想半天把时间复杂度nlogk当成nlogn了，答案想出来了还觉得不对</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Item</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> val;</span><br><span class=\"line\">        <span class=\"type\">int</span> feq;</span><br><span class=\"line\">        Item(<span class=\"type\">int</span> val,<span class=\"type\">int</span> feq)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.val=val;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.feq=feq;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] topKFrequent(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        Map&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        PriorityQueue&lt;Item&gt; minHeap = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(<span class=\"number\">1</span>,(a,b)-&gt;(a.feq-b.feq));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=nums.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            map.put(nums[i],map.getOrDefault(nums[i],<span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Integer key:map.keySet())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(minHeap.size()&lt;k)&#123;</span><br><span class=\"line\">                minHeap.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">Item</span>(key,map.get(key)));</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                minHeap.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">Item</span>(key,map.get(key)));</span><br><span class=\"line\">                minHeap.poll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[k];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=k-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            result[i] = minHeap.poll().val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["数组","哈希表","栈与队列","堆"]},{"title":"20 有效的括号","url":"/posts/d8bacbba.html","content":"<p>遇到左括号就入栈<br>遇到右括号就peek一下栈，栈空直接返回fasle。看看栈顶是不是和当前括号匹配，匹配出栈，不匹配返回false<br>最后检查当前栈是否为空</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValid</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        Stack&lt;Character&gt; k = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=len-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.charAt(i)==<span class=\"string\">&#x27;(&#x27;</span> || s.charAt(i)==<span class=\"string\">&#x27;&#123;&#x27;</span> || s.charAt(i)==<span class=\"string\">&#x27;[&#x27;</span>)&#123;</span><br><span class=\"line\">                k.push(s.charAt(i));</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(k.isEmpty()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> k.peek();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s.charAt(i)==<span class=\"string\">&#x27;)&#x27;</span> &amp;&amp; tmp==<span class=\"string\">&#x27;(&#x27;</span>) k.pop();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s.charAt(i)==<span class=\"string\">&#x27;]&#x27;</span> &amp;&amp; tmp==<span class=\"string\">&#x27;[&#x27;</span>) k.pop();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s.charAt(i)==<span class=\"string\">&#x27;&#125;&#x27;</span> &amp;&amp; tmp==<span class=\"string\">&#x27;&#123;&#x27;</span>) k.pop();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> k.isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["栈与队列"]},{"title":"算法题模版","url":"/posts/9872502a.html","content":"<p>中序遍历、层序遍历、回溯直接套模版，把模版丢这了</p>\n<h2 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; st = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">null</span> || !st.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                st.push(cur);</span><br><span class=\"line\">                cur = cur.left;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> st.pop();</span><br><span class=\"line\">                result.add(tmp.val);</span><br><span class=\"line\">                cur = tmp.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 前中后是栈实现，层序是队列实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkFun02</span><span class=\"params\">(TreeNode node)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Queue&lt;TreeNode&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">    que.offer(node);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!que.isEmpty()) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; itemList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> que.size();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">tmpNode</span> <span class=\"operator\">=</span> que.poll();</span><br><span class=\"line\">            itemList.add(tmpNode.val);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmpNode.left != <span class=\"literal\">null</span>) que.offer(tmpNode.left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmpNode.right != <span class=\"literal\">null</span>) que.offer(tmpNode.right);</span><br><span class=\"line\">            len--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        resList.add(itemList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h2><p>等到复习到这里再补充</p>\n","categories":["题解","代码随想录"],"tags":["回溯","二叉树","树的遍历","中序遍历","层序遍历"]},{"title":"94 二叉树的中序遍历","url":"/posts/c7a3beb3.html","content":"<p>递归法的三个遍历有手就行，迭代法的前序和后序用栈模拟一下也很好做，主要是中序的迭代法需要复习一下</p>\n<h2 id=\"迭代法\"><a href=\"#迭代法\" class=\"headerlink\" title=\"迭代法\"></a>迭代法</h2><p>先复习一下前后序迭代的思路</p>\n<h3 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h3><p>用一个栈存储叶子节点，每次从栈里弹出一个节点，前序遍历是先打印当前节点的值，然后将左右子节点压入栈里。</p>\n<h3 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h3><p>前序遍历的结果顺序是中左右，后序遍历的结果顺序是左右中。</p>\n<p>可以发现，前序遍历结果倒过来是右左中。也就是说改一下前序遍历中将子节点入栈的顺序，从左右子节点入栈变为右左子节点入栈，然后执行一遍前序遍历，并将结果数组反转，就可以获取到后序遍历的结果。</p>\n<h3 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h3><p>中序遍历：不断地把当前节点入栈，然后访问这个节点的左子节点，直到空为止<br>到了空后，弹出栈顶的节点，打印其的值，然后将其的右子节点入栈<br>这样就可以保证每次访问都是优先访问左边，然后访问中间，最后访问右边。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; st = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">null</span> || !st.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                st.push(cur);</span><br><span class=\"line\">                cur = cur.left;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> st.pop();</span><br><span class=\"line\">                result.add(tmp.val);</span><br><span class=\"line\">                cur = tmp.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["二叉树","树的遍历"]},{"title":"222 完全二叉树的节点数","url":"/posts/7d730c9d.html","content":"<p>直接遍历一遍树就行了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> count;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">countNodes</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        traversal(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">traversal</span><span class=\"params\">(TreeNode root)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        traversal(root.left);</span><br><span class=\"line\">        traversal(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["递归","二叉树","树的遍历"]},{"title":"459 重复的子字符串","url":"/posts/a1811133.html","content":"<h2 id=\"解法1\"><a href=\"#解法1\" class=\"headerlink\" title=\"解法1\"></a>解法1</h2><p>子字符串肯定是原字符串的前缀<br>子字符串重复n遍肯定是原字符串</p>\n<p>易得</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">repeatedSubstringPattern</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> tmpLen;</span><br><span class=\"line\">        <span class=\"type\">int</span> repeatNum;</span><br><span class=\"line\">        String tmpS;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=len-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            sb.append(s.charAt(i));</span><br><span class=\"line\">            tmpLen = sb.length();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(len%tmpLen==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                repeatNum = len/tmpLen;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(repeatNum==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                tmpS = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=repeatNum;j++)&#123;</span><br><span class=\"line\">                    tmpS = tmpS+sb.toString();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmpS.equals(s)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解法2\"><a href=\"#解法2\" class=\"headerlink\" title=\"解法2\"></a>解法2</h2><p>假设一个字符串s由子串ss拼成，那么s+s去掉首位字符后肯定还包含一个s</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">repeatedSubstringPattern</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> (s+s).substring(<span class=\"number\">1</span>,s.length()*<span class=\"number\">2</span>-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp.contains(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["字符串"]},{"title":"226 翻转二叉树","url":"/posts/aa576989.html","content":"<p>递归做，先递归处理左右子树</p>\n<p>左右子树处理完后，将当前节点的左右子树交换即可</p>\n<p>此时左右子树里的左右子树已经交换，当前节点的左右子树也交换，递归完全</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">invertTree</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        traversal(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traversal</span><span class=\"params\">(TreeNode root)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        traversal(root.left);</span><br><span class=\"line\">        traversal(root.right);</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> root.left;</span><br><span class=\"line\">        root.left = root.right;</span><br><span class=\"line\">        root.right = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["递归","二叉树","树的遍历"]},{"title":"11 盛最多水的容器","url":"/posts/a9decf0d.html","content":"<p>双指针法：使用两个指针，一个指向数组的起始位置（left），另一个指向数组的末尾位置（right）。<br>计算面积：计算当前两个指针所指向的线段与x轴构成的容器的面积，面积由较短的那条线的高度和两个指针之间的距离决定。<br>移动指针：为了寻找可能更大的面积，移动较短的那条线的指针向内侧移动一位，因为移动较长的线的指针不会增加容器的高度，而移动较短的线的指针有可能找到更高的线，从而增加面积。<br>更新最大面积：在每次移动指针后，计算新的面积，并更新最大面积。<br>重复步骤：重复上述过程，直到两个指针相遇。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxArea</span><span class=\"params\">(<span class=\"type\">int</span>[] height)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> height.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">area</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        area = Math.min(height[left],height[right]) * (right-left);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left&lt;right)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[left]&gt;=height[right])&#123;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">tmpA</span> <span class=\"operator\">=</span> Math.min(height[left],height[right]) * (right-left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmpA&gt;area) area = tmpA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> area;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","hot100"],"tags":["双指针","贪心"]},{"title":"283 移动0","url":"/posts/6662b667.html","content":"<p>维护快慢指针，快指针只指向当前不为0的值，慢指针只指向当前需要赋值的值。最后的快慢指针之间的偏移量就是0的数量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">moveZeroes</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">offset</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=l-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i+offset&lt;=l-<span class=\"number\">1</span> &amp;&amp; nums[i+offset]==<span class=\"number\">0</span>) offset++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i+offset&gt;l-<span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            nums[i] = nums[i+offset];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=offset-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            nums[l-<span class=\"number\">1</span>-i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","hot100"],"tags":["数组","双指针"]},{"title":"111 二叉树最小深度","url":"/posts/b1ad2811.html","content":"<p>层序遍历二叉树，当找到第一个左右子节点都是空的节点时，说明找到了最浅的叶子节点，此时的深度就是最小深度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minDepth</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> dep=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root!=<span class=\"literal\">null</span>) que.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!que.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> que.size();</span><br><span class=\"line\">            dep++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(len&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> que.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp.left==<span class=\"literal\">null</span> &amp;&amp; tmp.right==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> dep;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp.left!=<span class=\"literal\">null</span>) que.offer(tmp.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp.right!=<span class=\"literal\">null</span>) que.offer(tmp.right);</span><br><span class=\"line\">                len--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dep;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","代码随想录"],"tags":["二叉树","树的遍历"]},{"title":"128 最长连续序列","url":"/posts/6a29ceac.html","content":"<p>先去重，这里面重复元素只会影响解题</p>\n<p>然后只从起点开始找，找结尾最长的序列即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">longestConsecutive</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : nums) set.add(x);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">best</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : set) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!set.contains(x - <span class=\"number\">1</span>)) &#123;      <span class=\"comment\">// 只从起点开始扩展</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> x;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (set.contains(y)) y++;</span><br><span class=\"line\">                best = Math.max(best, y - x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> best;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","hot100"],"tags":["数组","哈希表"]},{"title":"104 二叉树最大深度","url":"/posts/af044e5b.html","content":"<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><p>层序遍历，看看遍历了几层，层数就是树的最大深度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxDepth</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">dep</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        que.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!que.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> que.size();</span><br><span class=\"line\">            dep++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(len&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> que.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp.left!=<span class=\"literal\">null</span>) que.offer(tmp.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp.right!=<span class=\"literal\">null</span>) que.offer(tmp.right);</span><br><span class=\"line\">                len--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dep;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>直接递归，每层返回左右子树的最大深度加1即可，不写实现了</p>\n","categories":["题解","代码随想录"],"tags":["递归","二叉树","树的遍历"]},{"title":"bug记录","url":"/posts/686803e4.html","content":"<p>Class com.sun.tools.javac.tree.JCTree$JCImport does not have member field ‘com.sun.tools.javac.tree.JCTree qualid’</p>\n<p>确认lombok要和jdk版本对应，我这里报错是因为项目jdk应当以17启动而我用了21</p>\n","categories":["杂项"]},{"title":"42 接雨水","url":"/posts/d34bb1c7.html","content":"<p>先找全局最高柱 maxIdx，再把数组分成左右两段；左段每个位置的水位由“左侧最高”决定，右段由“右侧最高”决定。</p>\n<p>对左边，从左边开始建立一个柱子单调递增的单调栈，这样两个柱子之间只会是凹槽。随后遍历这个栈，算出两个柱子之间的水量（水位由左侧较矮的柱子决定）。</p>\n<p>对右边的处理方法相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">trap</span><span class=\"params\">(<span class=\"type\">int</span>[] height)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> height.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxIdx</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"number\">0</span>,right=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=l-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[i]&gt;height[maxIdx]) maxIdx = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Stack&lt;Integer&gt; s1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=maxIdx;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[i]!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s1.isEmpty()) s1.push(i);</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(height[i]&gt;=height[s1.peek()]) s1.push(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s1.size()&gt;=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            right = s1.pop();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!s1.isEmpty())&#123;</span><br><span class=\"line\">                left = s1.pop();</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=left+<span class=\"number\">1</span>;i&lt;=right-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">                    count+=height[left]-height[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                right = left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Stack&lt;Integer&gt; s2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=l-<span class=\"number\">1</span>;i&gt;=maxIdx;i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[i]!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s2.isEmpty()) s2.push(i);</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(height[i]&gt;=height[s2.peek()]) s2.push(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s2.size()&gt;=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            left = s2.pop();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!s2.isEmpty())&#123;</span><br><span class=\"line\">                right = s2.pop();</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=left+<span class=\"number\">1</span>;i&lt;=right-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">                    count+=height[right]-height[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                left = right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","hot100"],"tags":["双指针","单调栈"]},{"title":"图片上传测试","url":"/posts/ea48e72b.html","content":"<p><img data-src=\"/a866374119273e756212004ebf8b0858438550870.jpg\"></p>\n","categories":["杂项"]},{"title":"hot100复刷目录","url":"/posts/198203e8.html","content":"<p>11 盛最多水的容器</p>\n<p>15 三数之和</p>\n","categories":["杂项"]},{"title":"3 无重复字符的最长子串","url":"/posts/bcafdab6.html","content":"<p>窗口是滑动的，右指针扩展，遇到问题后收缩窗口，左指针右移直到窗口内元素满足条件，随后继续拓展窗口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length()==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[] hmp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right=<span class=\"number\">0</span>;</span><br><span class=\"line\">        hmp[s.charAt(<span class=\"number\">0</span>)]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxL</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        right++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;right&lt;=s.length()-<span class=\"number\">1</span>;right++)&#123;</span><br><span class=\"line\">            hmp[s.charAt(right)] = hmp[s.charAt(right)]+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(hmp[s.charAt(right)]&gt;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                hmp[s.charAt(left)] = hmp[s.charAt(left)]-<span class=\"number\">1</span>;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxL = right-left+<span class=\"number\">1</span>&gt;maxL?right-left+<span class=\"number\">1</span>:maxL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","hot100"],"tags":["双指针","滑动窗口","字符串"]},{"title":"49 字母异位词","url":"/posts/a09172b7.html","content":"<p>将字符串转换为与字符数量唯一对应的key，存入map中，map存同一key对应的多个字符串即可。</p>\n<p>这个转换有多种方法</p>\n<ul>\n<li>直接对字符串转数组然后进行排序，再转换为字符串</li>\n<li>采用基于数组的哈希表，将字符串转为哈希表后再转换为字符串</li>\n</ul>\n<p>以第二种为例，来自GPT</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; <span class=\"title function_\">groupAnagrams</span><span class=\"params\">(String[] strs)</span> &#123;</span><br><span class=\"line\">        Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s : strs) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span>[] cnt = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">                cnt[s.charAt(i) - <span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">                key.append(<span class=\"string\">&#x27;#&#x27;</span>).append(cnt[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            map.computeIfAbsent(key.toString(), k -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;()).add(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(map.values());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["题解","hot100"],"tags":["哈希表","字符串"]}]